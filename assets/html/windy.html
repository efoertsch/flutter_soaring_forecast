<!DOCTYPE html>
<html>
<head>
    <script src="https://unpkg.com/leaflet@1.4.0/dist/leaflet.js"></script>
    <script src="https://api.windy.com/assets/map-forecast/libBoot.js"></script>
    <style>
    #windy {
      width: 100%;
      height: XXXHEIGHTXXXpx;
    }
    .turnpoint_label {
    position: absolute;
    width:100px;
    heigt:35px
    font-size:15px;
}
  </style>
</head>
<meta name="viewport" content="width=device-width  user-scalable=no zoom=1.0">
<body>
<div class="container" id="_flutter_target_do_not_delete">
<div id="windy"></div>
</div>

<style>
    #windy #mobile-ovr-select,
    #windy #embed-zoom {
      display: none !important;
    }
</style>

<script type="text/javascript">

function outputsize() {
  if (typeof window.flutter_inappwebview !== "undefined" && typeof window.flutter_inappwebview.callHandler !== "undefined")
    console.log("webview height: " + document.getElementById("_flutter_target_do_not_delete").offsetHeight);
     window.flutter_inappwebview.callHandler('newHeight', document.getElementById("_flutter_target_do_not_delete").offsetHeight);
  }
new ResizeObserver(outputsize).observe(_flutter_target_do_not_delete)


var windyStore;
var windyMap;
var taskLayerGroup;
var turnpointIcon;
var turnpointPolyLine;
var mapMarker = [];
var mapPolyLine = [];
var taskLayerGroup;
var origWindyMapLabels;
var isFlutterInAppWebViewReady = false;
var windyKey;
var lat;
var long;
var zoom;

window.addEventListener("flutterInAppWebViewPlatformReady", function(event) {
 isFlutterInAppWebViewReady = true;
 sendMsgToApp("isFlutterInAppWebViewReady = true");
 getWindyStartupParms();

});

function sendMsgToApp(msg){
  console.log(msg)
   if (isFlutterInAppWebViewReady){
      window.flutter_inappwebview.callHandler('print', msg);
   }
}

sendMsgToApp("Running windy.html javascript");


function setWindMap(store, map){
  windyStore = store;
  windyMap = map;
  // could not define icon until WindyAPI initialized
  //turnpointIcon = new L.DivIcon.SVGIcon( { "color":"rgb(255,0,0)" ,"fillOpacity": 1});
  turnpointPolyLine = {
                    color: 'red',
                    weight: 2,
                    opacity: 1,
                    zIndex: 1000,
                    className: 'polyTrack'};

  sendMsgToApp("calling getTaskTurnpointsForMap()");
  getTaskTurnpointsForMap();
}

function setBaseLayerToDefault(){
  sendMsgToApp("setting map to default");
  windyMap.baseLayer.setUrl("https://tiles-s.windy.com/tiles/v8.1/darkmap/{z}/{x}/{y}.png");
  windyMap.addLayer(origWindyMapLabels);
}

function setBaseLayerToGoogleMap(){
  sendMsgToApp("setting map to google");
  windyMap.baseLayer.options.subdomains = ["mt0", "mt1", "mt2", "mt3"];
  windyMap.baseLayer.setUrl("https://{s}.google.com/vt/lyrs=s,h&x={x}&y={y}&z={z}");
  windyMap.baseLayer.setOpacity(0.5);
   //windyMap.removeLayer(W.labelsLayer);
}

function setBaseLayerToArcGisMap(){
  sendMsgToApp("setting map to topo map");
  windyMap.baseLayer.setUrl("https://server.arcgisonline.com/ArcGIS/rest/services/World_Topo_Map/MapServer/tile/{z}/{y}/{x}");
  // windyMap.options.maxZoom = 18;
  windyMap.baseLayer.setOpacity(0.2);
 //windyMap.removeLayer(W.labelsLayer);
}

function setModel(model){
  sendMsgToApp('Requesting product:' + model);
  windyStore.set('product',model);
}

function setLayer(layer){
  sendMsgToApp('Requesting layer:' + layer);
  windyStore.set('overlay', layer);
}

function setAltitude(altitude){
  sendMsgToApp('Requesting level:' + altitude);
  windyStore.set('level', altitude);
}

function removeTaskFromMap() {
  if (windyMap && taskLayerGroup){
     windyMap.removeLayer(taskLayerGroup);
  }
  if (mapMarker) {
    mapMarker.length = 0;
  }
  if (mapPolyLine){
    mapPolyLine.length = 0;
  }
}


function redrawCompleted(){
  if (isFlutterInAppWebViewReady){
     window.flutter_inappwebview.callHandler('redrawCompleted');
  }
}

function getWindyStartupParms() {
  console.log("in getWindyStartupParms - isFlutterInAppWebViewReady =" + isFlutterInAppWebViewReady);
  if (isFlutterInAppWebViewReady) {
     window.flutter_inappwebview.callHandler('getWindyStartupParms').then(function(result){
      sendMsgToApp("called getWindyStartupParms(): " + result.toString);
      windyKey = result['key'];
      lat = result['lat'];
      long = result['long'];
      zoom = result['zoom']
      //console.log("WindyStartupParms key:" + windyKey + "  lat:" + lat + " long:" + long + " zoom:" + zoom);
      fireUpWindy() ;
    });
  }
}

// Call this once when map is loaded to see if task needs to be drawn
function getTaskTurnpointsForMap() {
  if (isFlutterInAppWebViewReady) {
    sendMsgToApp("calling getTaskTurnpointsForMap()");
     window.flutter_inappwebview.callHandler('getTaskTurnpointsForMap');
  }
}

// Called by app to pass in turnpoints
function drawTask(taskTurnpoints) {
  sendMsgToApp("drawTask(taskTurnpoints)");
  logTaskTurnpoints(taskTurnpoints);
  removeTaskFromMap();
  createMarkersAndPolyLine(taskTurnpoints);
}

// !!!.toFixed(1) gives (currently) error on end of taskTurnpoints[i].distanceFromStartingPoint on Chrome !!!
function createMarkersAndPolyLine(taskTurnpoints) {
  if (taskTurnpoints != null) {
    for (i = 0; i < taskTurnpoints.length; i++) {
      var latLong = [taskTurnpoints[i].latitudeDeg, taskTurnpoints[i].longitudeDeg];
      mapPolyLine.push(latLong);
      var marker = L.marker(latLong,{ opacity: 0.01 });
      marker.bindTooltip(taskTurnpoints[i].title + "<br> "
         + taskTurnpoints[i].distanceFromPriorTurnpoint.toFixed(1) + "/"
         + taskTurnpoints[i].distanceFromStartingPoint.toFixed(1) +"km"
      , {permanent: true, className: "turnpoint_label", offset: [0,0],direction:'center' });
      // !!! Remove .toFixed(1) if testing on Chrome !!!
      //marker.bindPopup(taskTurnpoints[i].title + "<br>" + taskTurnpoints[i].distanceFromStartingPoint.toFixed(1) +"km)");
      mapMarker.push(marker);
    }
    taskLayerGroup = L.layerGroup(mapMarker).addLayer(L.polyline(mapPolyLine,turnpointPolyLine));
    taskLayerGroup.addTo(windyMap);
    sendMsgToApp("Done with plotting turnpoints");
  }
}

function logTaskTurnpoints(taskTurnpoints){
  if (taskTurnpoints != null  && taskTurnpoints.length > 0) {
    for (i = 0; i < taskTurnpoints.length; i++) {
      var latLong = [taskTurnpoints[i].latitudeDeg, taskTurnpoints[i].longitudeDeg];
      sendMsgToApp("lat/long:" + taskTurnpoints[i].latitudeDeg + "/" + taskTurnpoints[i].longitudeDeg);
      sendMsgToApp("title" + taskTurnpoints[i].title);
      sendMsgToApp("distance from starting" + taskTurnpoints[i].distanceFromStartingPoint.toFixed(1));
      mapPolyLine.push(latLong);
    }
  } else {
    sendMsgToApp("taskTurnpoints null or empty");
  }
}


function fireUpWindy() {
   sendMsgToApp("Firing up Windy API with key" + windyKey);
   const options = {
     // Required: API key
     key: windyKey,
     // Put additional console output
     verbose: true,
     // Optional: Initial state of the map
     lat: lat,
     lon: long,
     zoom: zoom,
     isolines: 'pressure'
   };


   // Initialize Windy API
   windyInit(options, windyAPI => {
     // windyAPI is ready, and contain 'map', 'store',
     // 'picker' and other usefull stuff
     // .map is instance of Leaflet map
     const {
       map,
       utils,
       picker,
       pickerMobile,
       overlays,
       broadcast,
       store
     } = windyAPI;

     origWindyMapLabels = W.labelsLayer;

     // workaround - mobilePicker has bug so this tells windy to use desktopPicker
     var mobileMadeFalse = false;
     if (W.rootScope.isMobile) {
       W.rootScope.isMobile = false;
       mobileMadeFalse = true;
     }
     picker.on('pickerOpened', (e) => {
     if (mobileMadeFalse) {
        document.getElementsByClassName("picker-lines noselect")[0].parentNode.style.marginTop = "-70px";
        document.getElementsByClassName("picker-drag-me")[0].style.display = "none";
     }
     });
     // end of workaround

     broadcast.on('redrawFinished',(e) => {
       redrawCompleted();
     });

     // Observing change of .store value
     store.on('isImperial', isImperial => {
       sendMsgToApp(`isImperial was changed: ${ isImperial }`);
     });

     setWindMap(store, map);
     windyAPI.store.set('isImperial',false);
     windyAPI.store.set('isImperial',true);
     sendMsgToApp(" isImperial:" + windyAPI.store.get('isImperial'));
     //windyAPI.store.set('metric_temp', 'Â°F');
     sendMsgToApp(" isImperial:" + windyAPI.store.get('isImperial'));
     sendMsgToApp(" temp units:" + windyAPI.store.get('metric_temp'));
     sendMsgToApp("store.layer:" + store.get('overlay'));
     sendMsgToApp("levels:" + windyAPI.store.get('availLevels'));
     sendMsgToApp("Allowed products: " + windyAPI.store.getAllowed('product'));
     sendMsgToApp("Allowed overlays: " + windyAPI.store.getAllowed('overlay'));
     sendMsgToApp("Allowed levels: " + windyAPI.store.getAllowed('level'));
     outputsize();
   });
}
</script>
</body>
</html>